const fsPromises = require('fs').promises;
const path = require('path');
const { createBundleRenderer } = require('vue-server-renderer');
const cheerio = require('cheerio');
const Critters = require('critters-webpack-plugin');
const log = require('webpack-log');

const PLUGIN_NAME = 'PrerenderVueWebpackPlugin';
const SERVER_BUNDLE_FILE_NAME = 'vue-ssr-server-bundle.json';
const VUE_APP_ROOT = '#app';

/**
 * A Webpack plugin that allows you to pre-render your Vue applications and
 * optionally inline critical CSS at build time without a headless browser. For
 * pre-rendering, this plugin depends on the bundle renderer from
 * `vue-server-renderer` and the bundle-source map file generated by
 * `vue-server-renderer/server-plugin`. For inlining critical CSS, the plugin
 * uses Critters as a client.
 */
class PrerenderVueWebpackPlugin {
  /**
   * Create an instance of the plugin
   *
   * @param   {Object}  options
   *  Properties:
   *  entry <required, String>
   *    The entry corresponding to the emitted asset representing the Vue application
   *  template <required, String>
   *    The path to the template to be transformed.
   *  templateContext <optional, Object, default: {}>
   *    The context data used in the bundle rendering process
   *  root <optional, String, default: {@link VUE_APP_ROOT}>
   *    The root element in the template used by the Vue application
   *  serverBundleFileName <required, String, default: {@link SERVER_BUNDLE_FILE_NAME}>
   *    The file generated by `vue-server-renderer/server-plugin`.
   *  overwrite <optional, Boolean, default: false>
   *    If true, prioritizes the {@link this.template} path as the output path.
   *  outputPath <optional, String, default: {@link this.compilerOutput}>
   *    The path to output the transformed HTML to
   *  outputFileName <optional, String, default: {@link this.entry}.html>
   *    The outputted file name for the transformed html
   *  hook <optional, Function>
   *    Hook into the compilation process before any transformations begin.
   *  inlineCSS <optional, Object>
   *    Use Critters to inline critical CSS into the {@link this.template}.
   *    Properties:
   *    entries <optional, String[]>
   *      An array of entries/chunks whose CSS assets are used by the Vue app.
   *    externals <optional, String[]>
   *      An array of external assets that should be dynamically included
   *      in the compilation process via {@link this.hook}.
   *    mergeCSS <optional, Boolean, default: true>
   *      Merges the {@link entries} and {@link externals} into a single sheet
   *      and is passes to Critters. If `false`, individual sheets from both
   *      groups are processed separately by Critters.
   *  critters <optional, Object>
   *    An object that allows you to set/overwrite options passed to the
   *    Critters client.
   *
   * @return  {void}
   */
  constructor(options = {}) {
    this.entry = options.entry;
    this.template = options.template;
    this.templateContext = options.context || {};
    this.root = options.root || VUE_APP_ROOT;
    this.serverBundleFileName = options.serverBundleFileName || SERVER_BUNDLE_FILE_NAME;
    this.overwrite = options.overwrite || false;
    this.outputPath = options.outputPath;
    this.outputFileName = options.outputFileName;
    this.hook = options.hook;
    this.inlineCSS = options.inlineCSS;
    this.mergeCSS = options.inlineCSS && options.inlineCSS.mergeCSS;
    this.critters = options.critters;
    // Private
    this.entryPoints = [];
    this.logger = log({
      name: `[${PLUGIN_NAME}]`,
      unique: true,
      level: options.logLevel || 'info',
    });
  }

  /**
   * Webpack hook (entry point for the plugin)
   *
   * @param   {Object}  compiler  Compiler object from webpack tap
   *
   * @return  {void}
   */
  apply(compiler) {
    compiler.hooks.afterEmit.tapAsync(
      PLUGIN_NAME,
      async (compilation, callback) => {
        try {
          this.compilerOutput = compiler.options.output.path;
          this.entryPoints.push(this.getBundleEntrypoint(compilation));
          const emittedAssetName = this.getEmittedAssetFromChunkName(
            compilation,
          );
          // The presence of this emmitted asset name means we're ready to
          // pull in {@link this.serverBundleFileName} to render the vue app.
          if (emittedAssetName) {
            if (this.hook) {
              // Client hook into plugin
              this.logger.info(`[${this.entry}] - Executing client hook`);
              await this.hook.call(this, compiler, compilation);
            }
            let html = await this.getRenderedVueApp();
            // If the client provides a inlineCSS object, we want to inline
            // critical CSS into the template with the critters client.
            if (this.inlineCSS) {
              this.addMergedSheetsToCompilation(
                this.getStyleSheets(compilation),
                compilation,
              );
              html = await this.injectCriticalCSS(compiler, compilation, html);
            }
            await this.writeToOutput(html);
          }
        } catch (error) {
          this.logger.error(error);
        }
        callback();
      },
    );
  }

  /**
   * Fetches the bundle renderer using the {@link bundleSrc} derived from
   * {@link this.serverBundleFileName}.
   *
   * @param   {String}  bundleSrc  The source of the bundle
   *
   * @return  {Object}             Bundle renderer
   */
  static async getBundleRenderer(bundleSrc) {
    return createBundleRenderer(bundleSrc, {
      runInNewContext: false, // <- true borks the render
    });
  }

  /**
   * Writes transformed html to path specified.
   *
   * @param   {String}  html  The transformed html
   *
   * @return  {void}
   */
  async writeToOutput(html) {
    const outputPath = this.overwrite
      ? this.template
      : `${(this.outputPath || this.compilerOutput)}/${this.outputFileName || this.entry}.html`;
    this.logger.info(
      `[${this.entry}] - Writing transformed html to [${outputPath}]`,
    );
    await fsPromises.writeFile(path.resolve(outputPath), html);
  }

  /**
   * If stylesheets are provided, this function instantiates a Critters
   * client and executes against the {@link html}. The resultant html returned
   * is the original {@link html} with the Critical CSS imjected into it.
   *
   * @param   {Object}  compiler     Webpack compiler object
   * @param   {Object}  compilation  Webpack compilation object
   * @param   {String}  html         HTML template to receive inlined CSS.
   *
   * @return  {String}               HTML with inlined CSS injected into it.
   */
  async injectCriticalCSS(compiler, compilation, html) {
    const styleSheets = this.mergeCSS !== false
      ? [this.getStyleSheetName(compilation)]
      : this.getStyleSheets(compilation);
    let htmlWithInlinedCSS = html;
    if (styleSheets.length > 0) {
      this.logger.info(`[${this.entry}] - Injecting inline CSS into template`);
      const crittersClient = new Critters({
        additionalStylesheets: styleSheets,
        pruneSource: false,
        ...this.critters,
      });
      htmlWithInlinedCSS = await crittersClient.process(
        compiler,
        compilation,
        html,
      );
    } else {
      const { entries = [] } = this.inlineCSS;
      this.logger.warn(
        `[${this.entry}] - No stylesheets found to inline. Skipping inlining CSS. Are your entry names correct? Entries provided: ${entries}`,
      );
    }
    return htmlWithInlinedCSS;
  }

  /**
   * First creates a bundle renderer using the bundle source derived from
   * {@link this.serverBundleFileName}, then renders it to string, passing in
   * {@link this.templateContext}. Finally, loads the template into memory
   * using cheerio, where it replaces the {@link this.root} element
   * corresponding with the Vue application with the rendered fragment.
   *
   * @return  {String}  The provided template with the rendered Vue template
   *  injected into it.
   */
  async getRenderedVueApp() {
    this.logger.info(
      `[${this.entry}] - Rendering Vue app with(out) context and injecting into template`,
    );
    const { files: bundlesObj } = await this.getServerBundle();
    const bundleRenderer = await PrerenderVueWebpackPlugin.getBundleRenderer(
      this.getBundleSrc(bundlesObj),
    );
    const renderedVueApp = await bundleRenderer.renderToString(
      this.templateContext,
    );
    const $template = cheerio.load(await this.getTemplate());
    $template(this.root).replaceWith(renderedVueApp);
    return $template.html();
  }

  /**
   * The HTML template used by the plugin to inject the rendered Vue app (and
   * optionally the critical CSS generated by Critters).
   *
   * @return  {String}  The HTML template
   */
  async getTemplate() {
    const template = await fsPromises.readFile(
      path.resolve(this.template),
      'utf8',
    );
    return template;
  }

  /**
   * The deserialized server bundle generated by VueSSRServerPlugin.
   *
   * @return  {Object}  server bundle file
   */
  async getServerBundle() {
    const serverBundle = JSON.parse(
      await fsPromises.readFile(
        path.resolve(this.compilerOutput, this.serverBundleFileName),
        'utf8',
      ),
    );
    return serverBundle;
  }

  /**
   * The name of the stylesheet asset set in the compilation object by
   * {@link addMergedSheetsToCompilation}.
   *
   * @return  {String}  The stylesheet name
   */
  getStyleSheetName() {
    return `${PLUGIN_NAME}-${this.entry}-merged.css`;
  }

  /**
   * Adds a new stylesheet asset to the compilation object that contains all
   * of the gathered stylesheets passed by the client. The asset name is set
   * to the plugin name + {@link this.entry}. Used by Critters for inlining
   * CSS to the template.
   *
   * @param   {String[]}  sheets     The stylesheet assets
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {void}
   */
  addMergedSheetsToCompilation(sheets, compilation) {
    let mergedSource = '';
    sheets.forEach((sheet) => {
      mergedSource += compilation.assets[sheet].source();
    });
    // eslint-disable-next-line no-param-reassign
    compilation.assets[`${PLUGIN_NAME}-${this.entry}-merged.css`] = {
      source() {
        return mergedSource;
      },
      size() {
        return mergedSource.length;
      },
    };
  }

  /**
   * Pulls the stylesheet assets from the entries/chunks and externals passed
   * in {@link this.inlineCSS}.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String[]}             The stylesheet assets
   */
  getStyleSheets(compilation) {
    return this.getStyleSheetsByEntryName(compilation).concat(
      this.getStyleSheetsFromExternals(compilation),
    );
  }

  /**
   * Pulls stylesheets from the compilation assets by the
   * externals passed in {@link this.inlineCSS.externals}.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String[]}             The stylesheet assets corresponding to
   *  the externals passed
   */
  getStyleSheetsFromExternals(compilation) {
    const { externals = [] } = this.inlineCSS;
    const stylesheets = [];
    if (externals && externals.length > 0) {
      const { assets } = compilation.getStats().toJson();
      assets.forEach(({ name }) => {
        if (externals.findIndex((external) => external === name) > -1) {
          stylesheets.push(name);
        }
      });
    }
    return stylesheets;
  }

  /**
   * Pulls stylesheets from the compilation chunk-asset map by the
   * entries/chunks passed in {@link this.inlineCSS.entries}.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String[]}             The stylesheet assets corresponding to
   *  the entries/chunks passed
   */
  getStyleSheetsByEntryName(compilation) {
    const { entries = [] } = this.inlineCSS;
    const { assetsByChunkName = {} } = compilation.getStats().toJson();
    const stylesheets = (entries || []).reduce((acc, entry) => {
      // eslint-disable-next-line no-param-reassign
      acc = acc.concat(
        (assetsByChunkName[entry] || []).filter(
          (chunkName) => PrerenderVueWebpackPlugin.isCSS(chunkName),
        ),
      );
      return acc;
    }, []);
    return stylesheets;
  }

  /**
   * Similar to {@link getBundleEntrypoint} in that it returns an asset
   * representing the bundle entry point, however, this is the Chunk name to
   * emitted asset(s) mapping. Only used to distinguish that we have actually
   * emitted assets so that the plugin can work as expected.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String}               The bundle entry / emitted asset name
   */
  getEmittedAssetFromChunkName(compilation) {
    const { assetsByChunkName = {} } = compilation.getStats().toJson();
    const assetName = (assetsByChunkName[this.entry] || []).find(
      (chunkName) => PrerenderVueWebpackPlugin.isJS(chunkName),
    );
    return assetName || '';
  }

  /**
   * Gets the entry point ([name].bundle-[hash].js) name from the webpack
   * compilation.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String}               The entry point ([name].bundle-[hash].js)
   */
  getBundleEntrypoint(compilation) {
    const { entrypoints } = compilation.getStats().toJson();
    const { assets } = entrypoints[this.entry];
    return assets.find(
      (asset) => PrerenderVueWebpackPlugin.isJS(asset),
    ) || '';
  }

  /**
   * During compilation, multiple versions of an asset are generated and their
   * names are aggregated into {@link this.entryPoints}. One version
   * represents the asset that finally gets emitted, and a version used by
   * the Vue bundle renderer (typically the same source code wrapped in
   * "module.exports="). This method takes {@link fileSrcObj} which represents
   * the emitted asset {@link this.serverBundleFileName}, generated by
   * VueSSRServerPlugin, and pulls out the source of the  version used by
   * the server bundler.
   *
   * @param   {Object}  fileSrcObj  The object from the deserialized
   *  {@link this.serverBundleFileName} representing bundle names and their
   *  corresponding compiled source.
   *
   * @return  {String}              The bundle source.
   */
  getBundleSrc(fileSrcObj) {
    const entryPoint = this.entryPoints.find(
      (entry) => Object.prototype.hasOwnProperty.call(fileSrcObj, entry),
    );
    return fileSrcObj[entryPoint];
  }

  /**
   * Is the {@link file} JS? (file[.js]?)
   *
   * @param   {String}  file  The file to test against.
   *
   * @return  {Boolean}       True if {@link file} has .js extension
   */
  static isJS(file) {
    return /\.js(\?[^.]+)?$/.test(file);
  }

  /**
   * Is the {@link file} CSS? (file[.css]?)
   *
   * @param   {String}  file  The file to test against.
   *
   * @return  {Boolean}       True if {@link file} has .css extension
   */
  static isCSS(file) {
    return /\.css(\?[^.]+)?$/.test(file);
  }
}

module.exports = PrerenderVueWebpackPlugin;

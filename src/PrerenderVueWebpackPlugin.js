const fsPromises = require('fs').promises;
const path = require('path');
const { createBundleRenderer } = require('vue-server-renderer');
const cheerio = require('cheerio');
const Critters = require('critters-webpack-plugin');
const log = require('webpack-log');

const PLUGIN_NAME = 'PrerenderVueWebpackPlugin';
const SERVER_BUNDLE_FILE_NAME = 'vue-ssr-server-bundle.json';
const VUE_APP_ROOT = '#app';

/**
 * A Webpack plugin that allows you to pre-render your Vue applications and
 * optionally inline critical CSS at build time without a headless browser. For
 * pre-rendering, this plugin depends on the bundle renderer from
 * `vue-server-renderer` and the bundle-source map file generated by
 * `vue-server-renderer/server-plugin`. For inlining critical CSS, the plugin
 * uses Critters as a client.
 */
class PrerenderVueWebpackPlugin {
  /**
   * Create an instance of the plugin
   *
   * @param   {Object}  options
   *  Properties:
   *  entry <required, String>
   *    The entry corresponding to the emitted asset representing the Vue application
   *  template <required, String>
   *    The path to the template to be transformed.
   *  templateContext <optional, Object, default: {}>
   *    The context data used in the bundle rendering process
   *  root <optional, String, default: {@link VUE_APP_ROOT}>
   *    The root element in the template used by the Vue application
   *  serverBundleFileName <required, String, default: {@link SERVER_BUNDLE_FILE_NAME}>
   *    The file generated by `vue-server-renderer/server-plugin`.
   *  overwrite <optional, Boolean, default: false>
   *    If true, prioritizes the {@link this.template} path as the output path.
   *  outputPath <optional, String, default: {@link this.compilerOutput}>
   *    The path to output the transformed HTML to
   *  outputFileName <optional, String, default: {@link this.entry}.html>
   *    The outputted file name for the transformed html
   *  hook <optional, Function>
   *    Hook into the compilation process before any transformations begin.
   *  inlineCSS <optional, Object>
   *    Use Critters to inline critical CSS into the {@link this.template}.
   *    Properties:
   *    entries <optional, String[]>
   *      An array of entries/chunks whose CSS assets are used by the Vue app.
   *    externals <optional, String[]>
   *      An array of external assets that should be dynamically included
   *      in the compilation process via {@link this.hook}.
   *  critters <optional, Object>
   *    An object that allows you to set/overwrite options passed to the
   *    Critters client.
   *
   * @return  {void}
   */
  constructor(options = {}) {
    this.entry = options.entry;
    this.template = options.template;
    this.templateContext = options.templateContext || {};
    this.root = options.root || VUE_APP_ROOT;
    this.serverBundleFileName = options.serverBundleFileName || SERVER_BUNDLE_FILE_NAME;
    this.overwrite = options.overwrite || false;
    this.outputPath = options.outputPath;
    this.outputFileName = options.outputFileName;
    this.hook = options.hook;
    this.inlineCSS = options.inlineCSS;
    this.critters = options.critters;
    // Private
    this.cssMap = {};
    this.pluginExecutionCount = 0;
    this.emittedAsset = undefined;
    this.entryPoints = [];
    this.logger = log({
      name: `[${PLUGIN_NAME}]`,
      unique: true,
      level: options.logLevel || 'info',
    });
  }

  /**
   * Webpack hook (entry point for the plugin)
   *
   * @param   {Object}  compiler  Compiler object from webpack tap
   *
   * @return  {void}
   */
  apply(compiler) {
    compiler.hooks.afterEmit.tapAsync(
      PLUGIN_NAME,
      async (compilation, callback) => {
        try {
          this.compilerOutput = compiler.options.output.path;
          this.entryPoints.push(this.getBundleEntrypoint(compilation));
          this.emittedAsset = this.emittedAsset
            || this.getEmittedAssetFromChunkName(compilation);
          this.storeCSS(compilation);
          if (
            // Ensures server bundle file is available for Vue app rendering
            (await this.hasServerBundle())
            // Prevents duplicative I/O
            && !this.pluginExecutionCount
            // {@link apply} is called when VueSSRServerPlugin emits the
            // server bundle file and when the application assets are
            // emitted. The emitted app assets contain the CSS we need for
            // inlining and are stored via {@link storeCSS}. The presense of
            // the emittedAsset signifies that we have our css assets.
            && (this.inlineCSS ? this.emittedAsset : true)
          ) {
            this.pluginExecutionCount += 1;
            if (this.hook) {
              // Client hook into plugin
              this.logger.info(`[${this.entry}] - Executing client hook`);
              await this.hook.call(this, compiler, compilation);
            }
            let html = await this.getRenderedVueApp();
            // If the client provides a inlineCSS object, we want to inline
            // critical CSS into the template with the critters client.
            if (this.inlineCSS) {
              this.addMergedSheetsToCompilation(compilation);
              html = await this.injectCriticalCSS(compiler, compilation, html);
            }
            await this.writeToOutput(html);
          }
        } catch (error) {
          this.logger.error(error);
        }
        callback();
      },
    );
  }

  /**
   * Stores the CSS source for the entry within the instance of the plugin
   * to guaratee we have a reference to it when we add them to the compilation
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {void}
   */
  storeCSS(compilation) {
    const assets = this.getStyleSheetsByEntryName(compilation);
    const cssMap = {};
    assets.forEach((asset) => {
      cssMap[asset] = compilation.assets[asset].source();
    });
    this.cssMap = Object.assign(this.cssMap, cssMap);
  }

  /**
   * Determines if we can perform our transformations. Need the server bundle
   * file generated by VueSSRServerPlugin emitted and the the source of the
   * entry must be available in that server bundle.
   *
   * @return  {Boolean}  Are we good to perform transformations?
   */
  async hasServerBundle() {
    const bool = (await this.serverBundleExists()) && (await this.hasBundleSrc());
    return bool;
  }

  /**
   * Checks whether or not the {@link this.serverBundleFileName} exists in
   * the compiler output path. If it does, we're ready to do our
   * transformations.
   *
   * @return  {Boolean}  server bundle exists in file system?
   */
  async serverBundleExists() {
    let exists = false;
    try {
      const stat = await fsPromises.lstat(
        path.resolve(this.compilerOutput, this.serverBundleFileName),
      );
      exists = stat.isFile();
    } catch (error) {
      // File not found
    }
    return exists;
  }

  /**
   * Fetches the bundle renderer using the {@link bundleSrc} derived from
   * {@link this.serverBundleFileName}.
   *
   * @param   {String}  bundleSrc  The source of the bundle
   *
   * @return  {Object}             Bundle renderer
   */
  static async getBundleRenderer(bundleSrc) {
    return createBundleRenderer(bundleSrc, {
      runInNewContext: false, // <- true borks the render
    });
  }

  /**
   * Writes transformed html to path specified.
   *
   * @param   {String}  html  The transformed html
   *
   * @return  {void}
   */
  async writeToOutput(html) {
    const outputPath = this.overwrite
      ? this.template
      : `${this.outputPath || this.compilerOutput}/${
        this.outputFileName || this.entry
      }.html`;
    this.logger.info(
      `[${this.entry}] - Writing transformed html to [${outputPath}]`,
    );
    await fsPromises.writeFile(path.resolve(outputPath), html);
  }

  /**
   * If stylesheets are provided, this function instantiates a Critters
   * client and executes against the {@link html}. The resultant html returned
   * is the original {@link html} with the Critical CSS imjected into it.
   *
   * @param   {Object}  compiler     Webpack compiler object
   * @param   {Object}  compilation  Webpack compilation object
   * @param   {String}  html         HTML template to receive inlined CSS.
   *
   * @return  {String}               HTML with inlined CSS injected into it.
   */
  async injectCriticalCSS(compiler, compilation, html) {
    const styleSheets = [this.getStyleSheetName(compilation)];
    let htmlWithInlinedCSS = html;
    if (styleSheets.length > 0) {
      this.logger.info(`[${this.entry}] - Injecting inline CSS into template`);
      try {
        const crittersClient = new Critters({
          additionalStylesheets: styleSheets,
          pruneSource: false,
          external: false,
          ...this.critters,
        });
        htmlWithInlinedCSS = await crittersClient.process(
          compiler,
          compilation,
          html,
        );
      } catch (error) {
        this.logger.error(error);
      }
    } else {
      const { entries = [] } = this.inlineCSS;
      this.logger.warn(
        `[${this.entry}] - No stylesheets found to inline. Skipping inlining CSS. Are your entry names correct? Entries provided: ${entries}`,
      );
    }
    return htmlWithInlinedCSS;
  }

  /**
   * First creates a bundle renderer using the bundle source derived from
   * {@link this.serverBundleFileName}, then renders it to string, passing in
   * {@link this.templateContext}. Finally, loads the template into memory
   * using cheerio, where it replaces the {@link this.root} element
   * corresponding with the Vue application with the rendered fragment.
   *
   * @return  {String}  The provided template with the rendered Vue template
   *  injected into it.
   */
  async getRenderedVueApp() {
    this.logger.info(
      `[${this.entry}] - Rendering Vue app and injecting into template`,
    );
    const { files: bundlesObj } = await this.getServerBundle();
    const bundleRenderer = await PrerenderVueWebpackPlugin.getBundleRenderer(
      this.getBundleSrc(bundlesObj),
    );
    const renderedVueApp = await bundleRenderer.renderToString(
      this.templateContext,
    );
    const $template = cheerio.load(await this.getTemplate());
    $template(this.root).replaceWith(renderedVueApp);
    return $template.html();
  }

  /**
   * The HTML template used by the plugin to inject the rendered Vue app (and
   * optionally the critical CSS generated by Critters).
   *
   * @return  {String}  The HTML template
   */
  async getTemplate() {
    const template = await fsPromises.readFile(
      path.resolve(this.template),
      'utf8',
    );
    return template;
  }

  /**
   * The deserialized server bundle generated by VueSSRServerPlugin.
   *
   * @return  {Object}  server bundle file
   */
  async getServerBundle() {
    if (!this.serverBundle) {
      this.serverBundle = JSON.parse(
        await fsPromises.readFile(
          path.resolve(this.compilerOutput, this.serverBundleFileName),
          'utf8',
        ),
      );
    }
    return this.serverBundle;
  }

  /**
   * The name of the stylesheet asset set in the compilation object by
   * {@link addMergedSheetsToCompilation}.
   *
   * @return  {String}  The stylesheet name
   */
  getStyleSheetName() {
    return `${PLUGIN_NAME}-${this.entry}-merged.css`;
  }

  /**
   * Adds a new stylesheet asset to the compilation object that contains all
   * of the gathered stylesheets passed by the client. The asset name is set
   * to the plugin name + {@link this.entry}. Used by Critters for inlining
   * CSS to the template.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {void}
   */
  addMergedSheetsToCompilation(compilation) {
    let mergedSource = '';
    Object.keys(this.cssMap).forEach((key) => {
      mergedSource += this.cssMap[key];
    });
    this.getStyleSheetsFromExternals(compilation).forEach((sheet) => {
      mergedSource += compilation.assets[sheet].source();
    });
    // eslint-disable-next-line no-param-reassign
    compilation.assets[`${PLUGIN_NAME}-${this.entry}-merged.css`] = {
      source() {
        return mergedSource;
      },
      size() {
        return mergedSource.length;
      },
    };
  }

  /**
   * Pulls stylesheets from the compilation assets by the
   * externals passed in {@link this.inlineCSS.externals}.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String[]}             The stylesheet assets corresponding to
   *  the externals passed
   */
  getStyleSheetsFromExternals(compilation) {
    const { externals = [] } = this.inlineCSS;
    const stylesheets = [];
    if (externals && externals.length > 0) {
      const { assets } = compilation.getStats().toJson();
      assets.forEach(({ name }) => {
        if (externals.findIndex((external) => external === name) > -1) {
          stylesheets.push(name);
        }
      });
    }
    return stylesheets;
  }

  /**
   * Pulls stylesheets from the compilation chunk-asset map by the
   * entries/chunks passed in {@link this.inlineCSS.entries}.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String[]}             The stylesheet assets corresponding to
   *  the entries/chunks passed
   */
  getStyleSheetsByEntryName(compilation) {
    const { entries = [] } = this.inlineCSS || {};
    const { assetsByChunkName = {} } = compilation.getStats().toJson();
    const stylesheets = (entries || []).reduce((acc, entry) => {
      // eslint-disable-next-line no-param-reassign
      acc = acc.concat(
        (assetsByChunkName[entry] || []).filter(
          (chunkName) => PrerenderVueWebpackPlugin.isCSS(chunkName),
        ),
      );
      return acc;
    }, []);
    return stylesheets;
  }

  /**
   * Similar to {@link getBundleEntrypoint} in that it returns an asset
   * representing the bundle entry point, however, this is the Chunk name to
   * emitted asset(s) mapping. Only used to distinguish that we have actually
   * emitted assets so that the plugin can work as expected.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String}               The bundle entry / emitted asset name
   */
  getEmittedAssetFromChunkName(compilation) {
    const { assetsByChunkName = {} } = compilation.getStats().toJson();
    const assetName = (assetsByChunkName[this.entry] || []).find(
      (chunkName) => PrerenderVueWebpackPlugin.isJS(chunkName),
    );
    return assetName;
  }

  /**
   * Gets the entry point ([name].bundle-[hash].js) name from the webpack
   * compilation.
   *
   * @param   {Object}  compilation  Webpack compilation object
   *
   * @return  {String}               The entry point ([name].bundle-[hash].js)
   */
  getBundleEntrypoint(compilation) {
    const { entrypoints } = compilation.getStats().toJson();
    const { assets } = entrypoints[this.entry];
    return assets.find((asset) => PrerenderVueWebpackPlugin.isJS(asset)) || '';
  }

  /**
   * During compilation, multiple versions of an asset are generated and their
   * names are aggregated into {@link this.entryPoints}. One version
   * represents the asset that finally gets emitted, and a version used by
   * the Vue bundle renderer (typically the same source code wrapped in
   * "module.exports="). This method takes {@link fileSrcObj} which represents
   * the emitted asset {@link this.serverBundleFileName}, generated by
   * VueSSRServerPlugin, and pulls out the source of the  version used by
   * the server bundler.
   *
   * @param   {Object}  fileSrcObj  The object from the deserialized
   *  {@link this.serverBundleFileName} representing bundle names and their
   *  corresponding compiled source.
   *
   * @return  {String}              The bundle source.
   */
  getBundleSrc(fileSrcObj) {
    const entryPoint = this.entryPoints.find(
      (entry) => Object.prototype.hasOwnProperty.call(fileSrcObj, entry),
    );
    return fileSrcObj[entryPoint];
  }

  /**
   * Are any of the entry points aggregated have a corresponding bundle
   * source contained within {@link this.serverBundleFileName}.
   *
   * @return  {Boolean}  The {@link this.entry} has a bundle source file
   *  contained in the server bundle.
   */
  async hasBundleSrc() {
    const { files: bundlesObj } = await this.getServerBundle();
    let doesHaveBundleSrc = false;
    this.entryPoints.forEach((entry) => {
      if (Object.keys(bundlesObj).includes(entry)) {
        doesHaveBundleSrc = true;
      }
    });
    return doesHaveBundleSrc;
  }

  /**
   * Is the {@link file} JS? (file[.js]?)
   *
   * @param   {String}  file  The file to test against.
   *
   * @return  {Boolean}       True if {@link file} has .js extension
   */
  static isJS(file) {
    return /\.js(\?[^.]+)?$/.test(file);
  }

  /**
   * Is the {@link file} CSS? (file[.css]?)
   *
   * @param   {String}  file  The file to test against.
   *
   * @return  {Boolean}       True if {@link file} has .css extension
   */
  static isCSS(file) {
    return /\.css(\?[^.]+)?$/.test(file);
  }
}

module.exports = PrerenderVueWebpackPlugin;
